/**
 * @brief Library reactors for the line sensors on the
 * <a href="https://www.pololu.com/docs/0J86">Pololu 3pi+ 2040 robot</a>.
 *
 * NOTE: The line sensors cannot be used together with the bump sensors. See <a
 * href="https://www.pololu.com/docs/0J86/6.5">Section 6.5 of the Pololu 3pi+ 2040 User's Guide</a>.
 *
 * Upon receiving a trigger input, read the five line sensors and either use the inputs to calibrate
 * the sensors or produce their values on the `reflect` output as an array with five elements. The
 * reactor will be initially in calibration mode until a false-valued `calibrate` input is provided.
 * The first element corresponds to the leftmost sensor, and the last element corresponds to the
 * rightmost sensor. The readings are between 0 and 1024, with higher readings corresponding to less
 * light being detected.
 *
 * The `calibrate` input, if true, puts the reactor in calibration mode and, if false, puts it in
 * measurement mode. A typical usage is to provide a true-valued `calibrate` input at startup,
 * during which the robot should be rolled over light and dark surfaces, and a false-valued
 * `calibrate` input after some time. The `trigger` input would normally be provided periodically.
 *
 * @author Abhi Gundrala
 * @author Edward A. Lee
 */
target uC

preamble {=
  #include <ir_sensors.h>
  typedef struct {
    uint16_t value[5];
  } LineReflect;
=}

reactor Line {
  input calibrate: bool
  input trigger: bool
  output reflect: LineReflect

  state calibrating: bool = true
  state calibrated: bool = false  // Indicator of whether calibration has occurred at least once.

  reaction(calibrate) {=
    self->calibrating = calibrate->value;
  =}

  reaction(trigger) -> reflect {=
    LineReflect reflect_sample;
    if (self->calibrating) {
      line_sensors_calibrate();
      self->calibrated = true;
    } else {
      if (!self->calibrated) {
        // Calibration has not been performed, so read raw data.
        line_sensors_read();
        for (int i=0; i<5; i++) {
          reflect_sample.value[i] = line_sensors[i];
        }
      } else {
        line_sensors_read_calibrated();
        for (int i=0; i<5; i++) {
          reflect_sample.value[i] = line_sensors_calibrated[i];
        }
      }
      lf_set(reflect, reflect_sample);
    }
  =}
}
